<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gulp安装和简单使用]]></title>
    <url>%2Ffrontend%2F2018%2F09%2F04%2Fgulp%2F</url>
    <content type="text"><![CDATA[一、安装nodejs nodejs官网下载安装文件安装 安装完成后，终端输入node-v打印出nodejs的版本号，这时候nodejs已经安装成功 新版本的nodejs集成了npm。终端输入npm-v打印出npm的版本号 二、安装gulp(全局) 终端输入 1npm install gulp -g 测试安装是否成功，终端输入gulp-v 三、配置项目 package.json是基于node.js项目必不可少的配置文件，用于存放项目根目录的普通json文件重点内容 在终端进入文件根目录，执行npm init，一路回车，最终在项目根目录下生成package.json文件 1234567891011&#123; "name": "gulp_test", /*项目名,切记这里命名不要与模块一样，如命名为gulp，要地安装gulp时就会出错*/ "version": "1.0.0", /*版本号*/ "description": "", /*描述*/ "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", /*作者*/ "license": "ISC" /*项目许可协议*/&#125; 四、本地安装gulp及gulp插件本地安装gulp 全局安装gulp是为了执行gulp任务，本地安装gulp是为了调用gulp插件的功能进入你的项目文件路径中 1npm install gulp --save-dev –svae-dev 的作用就是将安装的模块写入package.json中 安装完成后项目变化 node_modules文件夹&gt;&gt;gulp模块被下载到这个文件夹中 package.json中写入了devDependencies字段，并在该字段下填充了gulp模块名 本地安装gulp插件 这里我们安装使用最多的必备的几个插件 删除文件–del 语法检查–gulp-jshint 合并文件–gulp-concat 压缩代码–gulp-uglify 文件重命名–gulp-rename css压缩–gulp-minify-css 1npm install --save-dev del jshint gulp-jshint gulp-concat gulp-uglify gulp-rename gulp-minify-css npm安装插件，可以单独安装，也可以几个一起安装空格隔开。 单独安装1npm install --save-dev del 上面jshint gulp-jshint说明gulp-jshint 2.0版本必须先下载jshint，使用npm安装：1npm install jshint gulp-jshint 五、创建gulpfile.js文件 gulp只有五个方法src，task，dest，run，watch 在项目根目录下创建gulpfile.js文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*引入gulp及相关插件 require('node_modules里对应模块')*/var gulp = require('gulp');var jshint = require('gulp-jshint');//js检查var concat = require('gulp-concat');//js合并var uglify = require('gulp-uglify');//js压缩var rename = require('gulp-rename');//文件重命名var minifycss = require('gulp-minify-css');//css压缩var del = require('del');//文件删除//创建任务，进行js代码检查gulp.task('jshint',function()&#123; return gulp.src('js/**/*.js') //检查文件：js目录下所有的js文件 .pipe(jshint()) //进行js检查 .pipe(jshint.reporter('default')); //对代码进行报错提示&#125;);//创建任务，进行js压缩gulp.task('script', function () &#123; return gulp.src('js/**/*.js') //检查文件：js目录下所有的js文件 .pipe(concat('all.js')) //合并all.js文件 .pipe(gulp.dest('dist')) //合并后的文件输出的目录 .pipe(uglify()) //压缩all.js文件 .pipe(rename(&#123;suffix: '.min'&#125;))//rename压缩后的文件名 .pipe(gulp.dest('dist/js/')); //压缩后的文件输出的目录&#125;);//创建任务，进行css压缩gulp.task('minifycss', function () &#123; return gulp.src('css/**/*.css') //获取文件：css目录下所有的css文件 .pipe(minifycss()) //执行压缩 .pipe(rename(&#123;suffix: '.min'&#125;))//rename压缩后的文件名 .pipe(gulp.dest('dist/css/')); //压缩后的文件输出的目录&#125;);//实时监听文件变化，执行各个任务gulp.task('watch', function () &#123; gulp.watch('js/**/*.js', ['jshint']); gulp.watch('js/**/*.js', ['script']); gulp.watch('css/**/*.css', ['minifycss']);&#125;);//在编译文件之前删除一些文件gulp.task('clean', function () &#123; return del('dist/**/*');&#125;);//默认任务gulp.task('default', ['clean'], function () &#123; gulp.run('jshint','script', 'minifycss', 'watch');&#125;); 六、运行gulp在终端输入并回车执行1gulp]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>gulp</tag>
        <tag>前端自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基本算法]]></title>
    <url>%2Ffrontend%2F2018%2F08%2F27%2Fjs-algorithm%2F</url>
    <content type="text"><![CDATA[时间复杂度：算法的时间复杂度是一个函数，描述了算法的运行时间。时间复杂度越低，效率越高 一个算法，运行了几次时间复杂度就为多少，如运行了n次，则时间复杂度为O(n) 1、冒泡排序 比较相邻的两个元素，如果前一个比后一个大，则交换位置。按照相邻元素的比较，第一轮的时候最后一个元素已经为最大的一个，所以最后一个元素不用比较 12345678910111213141516 function bubbleSort(arr)&#123; for(var i=0; i&lt;arr.length-1; i++)&#123; for(var j=0; j&lt;arr.length-i-1; j++)&#123; //&gt;从小到大排序 //&lt;从大到小排序 if(arr[j] &gt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp &#125; &#125; &#125; return arr;&#125;var arr=[5,6,2,1,3,8,7,1.2,5.5,4.5];console.log(bubbleSort(arr)); 2、快速排序 快速排序是对冒泡排序的一种改进，第一次排序时将数据分为两部分，一部分比另一部分的所有数据都要小。然后递归调用，在两边都实行快速排序。 123456789101112131415161718192021function quickSort(arr)&#123; if(arr.length &lt;= 1)&#123;return arr;&#125; //中心点 var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = [], right = []; //左右都实行快速排序 for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; //递归 连接左右 return quickSort(left).concat([pivot], quickSort(right));&#125;var arr=[5,6,2,1,3,8,7,1.2,5.5,4.5];console.log(quickSort(arr)); 3、判断一个单词是否有回文 回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider 123function checkPalindrom(str) &#123; return str == str.split('').reverse().join('');&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http和https的区别与联系]]></title>
    <url>%2Ffrontend%2F2018%2F08%2F21%2Fhttp-diffr%2F</url>
    <content type="text"><![CDATA[超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 一、HTTP和HTTPS的基本概念HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。二、HTTP与HTTPS有什么区别？ HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。 简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 HTTPS和HTTP的区别主要如下： https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 三、HTTPS的工作原理 我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 客户端发起HTTPS请求 这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。 这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。 如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。 六、HTTPS的优点 正是由于HTTPS非常的安全，攻击者无法从中找到下手的地方，从站长的角度来说，HTTPS的优点有以下2点： SEO方面 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 安全性 尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处： （1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 （3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 七、HTTPS的缺点 虽然说HTTPS有很大的优势，但其相对来说，还是有些不足之处的，具体来说，有以下2点： SEO方面 据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。 而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。 最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 经济方面 （1）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 （2）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。 （3）HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。 （4）HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。 （5）HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现继承的方式]]></title>
    <url>%2Ffrontend%2F2018%2F08%2F21%2Fjs-inherit%2F</url>
    <content type="text"><![CDATA[js实现继承的方式 JS作为面向对象的弱类型语言，继承是其非常强大的特性之一 定义一个父类12345678910111213//定义一个动物类function Animal(name)&#123; //属性 this.name = name || 'Animal'; //实例方法 this.sleep = function()&#123; console.log(this.name + '正在睡觉'); &#125;&#125;//原型方法Animal.prototype.eat = function(food)&#123; console.log(this.name + '正在吃' + food)&#125; 1、原型链继承 核心：将父类的实例作为子类的原型 123456789101112function Cat()&#123;&#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat'//testvar cat = new Cat();console.log(cat.name);//catconsole.log(cat.eat('fish'));//cat正在吃fishconsole.log(cat.sleep());//cat正在睡觉console.log(cat instanceof Animal);//trueconsole.log(cat instanceof Cat);//true 特点 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点 要想为子类新增属性和方法，可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 2、构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 1234567891011function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom'&#125;//testvar cat = new Cat();console.log(cat.name);//Tomconsole.log(cat.sleep());//Tom正在睡觉console.log(cat instanceof Animal);//falseconsole.log(cat instanceof Cat);//true 特点 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象） 缺点 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 3、实例继承 核心：为父类实例添加新特性，作为子类实例返回 123456789101112function Cat(name)&#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;//testvar cat = new Cat();console.log(cat.name);//Tomconsole.log(cat.sleep());//Tom正在睡觉console.log(cat instanceof Animal);//trueconsole.log(cat instanceof Cat);//false 特点 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果 缺点 实例是父类的实例，不是子类的实例 不支持多继承 4、拷贝继承1234567891011121314function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125;//testvar cat = new Cat();console.log(cat.name);//Tomconsole.log(cat.sleep());//Tom正在睡觉console.log(cat instanceof Animal);//falseconsole.log(cat instanceof Cat);//true 特点 支持多继承 缺点 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 5、组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 1234567891011121314function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();//组合继承需要修复构造函数指向的。Cat.prototype.constructor = Cat;//testvar cat = new Cat();console.log(cat.name);//Tomconsole.log(cat.sleep());//Tom正在睡觉console.log(cat instanceof Animal);//trueconsole.log(cat instanceof Cat);//true 特点 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 6、寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 12345678910111213141516171819function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();Cat.prototype.constructor = Cat; // 需要修复下构造函数//testvar cat = new Cat();console.log(cat.name);//Tomconsole.log(cat.sleep());//Tom正在睡觉console.log(cat instanceof Animal);//trueconsole.log(cat instanceof Cat);//true 特点 堪称完美 缺点 实现较为复杂]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>继承方式</tag>
      </tags>
  </entry>
</search>
