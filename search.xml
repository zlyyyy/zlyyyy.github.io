<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[yarn]]></title>
    <url>%2Farticle%2F2019%2F01%2F30%2Fyarn%2F</url>
    <content type="text"><![CDATA[yarn的常用命令安装yarn1npm install -g yarn 安装成功后，查看版本号1yarn --version 创建文件夹 yarn1md yarn 进入yarn文件夹1cd yarn 初始化项目1yarn init // 同npm init，执行输入信息后，会生成package.json文件 yarn的配置项1234yarn config list // 显示所有配置项yarn config get &lt;key&gt; //显示某配置项yarn config delete &lt;key&gt; //删除某配置项yarn config set &lt;key&gt; &lt;value&gt; [-g|--global] //设置配置项 安装包123456yarn install //安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lockyarn install --flat //安装一个包的单一版本yarn install --force //强制重新下载所有包yarn install --production //只安装dependencies里的包yarn install --no-lockfile //不读取或生成yarn.lockyarn install --pure-lockfile //不生成yarn.lock 添加包（会更新package.json和yarn.lock）123456789101112yarn add [package] // 在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中yarn add [package]@[version] // 安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数yarn add [package]@[tag] // 安装某个tag（比如beta,next或者latest）//不指定依赖类型默认安装到dependencies里，你也可以指定依赖类型：yarn add --dev/-D // 加到 devDependenciesyarn add --peer/-P // 加到 peerDependenciesyarn add --optional/-O // 加到 optionalDependencies//默认安装包的主要版本里的最新版本，下面两个命令可以指定版本：yarn add --exact/-E // 安装包的精确版本。例如yarn add foo@1.2.3会接受1.9.1版，但是yarn add foo@1.2.3 --exact只会接受1.2.3版yarn add --tilde/-T // 安装包的次要版本里的最新版。例如yarn add foo@1.2.3 --tilde会接受1.2.9，但不接受1.3.0 发布包1yarn publish 移除一个包1yarn remove &lt;packageName&gt;：移除一个包，会自动更新package.json和yarn.lock 更新一个依赖1yarn upgrade 用于更新包到基于规范范围的最新版本 运行脚本1yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本 显示某个包的信息1yarn info &lt;packageName&gt; 可以用来查看某个模块的最新版本信息 缓存1234yarn cache yarn cache list # 列出已缓存的每个包 yarn cache dir # 返回 全局缓存位置 yarn cache clean # 清除缓存 npm 与 yarn命令比较 NPM YARN 说明 npm init yarn init 初始化某个项目 npm install/link yarn install/link 默认的安装依赖操作 npm install taco –save yarn add taco 安装某个依赖，并且默认保存到package npm uninstall taco –save yarn remove taco 移除某个依赖项目 npm install taco –save-dev yarn add taco –dev 安装某个开发时依赖项目 npm update taco –save yarn upgrate taco 更新某个依赖项目 npm install taco –global yarn global add taco 安装某个全局依赖项目 npm publish/login/logout yarn publish/login/logout 发布/登录/登出，一系列npm registry操作 npm run/test yarn run/test 运行某个命令 npm 与 yarn相关问题比较:npm模块的依赖: npm存在一些历史遗留问题，请看下图： 比如说你的项目模块依赖是图中描述的，@1.2.1代表这个模块的版本。在你安装A的时候需要安装依赖C和D，很多依赖不会指定版本号，默认会安装最新的版本，这样就会出现问题：比如今天安装模块的时候C和D是某一个版本，而当以后C、D更新的时候，再次安装模块就会安装C和D的最新版本，如果新的版本无法兼容你的项目，你的程序可能就会出BUG，甚至无法运行。这就是npm的弊端，而yarn为了解决这个问题推出了yarn.lock的机制，这是作者项目中的yarn.lock文件。 yarn.lock文件格式1234567891011# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.# yarn lockfile v1"@babel/code-frame@7.0.0", "@babel/code-frame@^7.0.0", "@babel/code-frame@^7.0.0-beta.35": version "7.0.0" resolved "https://registry.yarnpkg.com/@babel/code-frame/-/code-frame-7.0.0.tgz#06e2ab19bdb535385559aabb5ba59729482800f8" integrity sha512-OfC2uemaknXr87bdLUkWog7nYuliM9Ij5HUcajsVcMCpQrcLmtxRbVFTIqmcSkSeYRBFBRxs2FiUqFJDLdiebA== dependencies: "@babel/highlight" "^7.0.0" ... 大家会看到，这个文件已经把依赖模块的版本号全部锁定，当你执行yarn install的时候，yarn会读取这个文件获得依赖的版本号，然后依照这个版本号去安装对应的依赖模块，这样依赖就会被锁定，以后再也不用担心版本号的问题了。其他人或者其他环境下使用的时候，把这个yarn.lock拷贝到相应的环境项目下再安装即可。 注意：这个文件不要手动修改它，当你使用一些操作如yarn add时，yarn会自动更新yarn.lock。]]></content>
  </entry>
  <entry>
    <title><![CDATA[react基础回顾]]></title>
    <url>%2Ffrontend%2F2019%2F01%2F26%2Freact%2F</url>
    <content type="text"><![CDATA[开发环境搭建-这里使用yarn安装yarn 特点 速度超快。 Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。 超级安全。 在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。 超级可靠。 使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。 安装 12345// 1、下载node.js，使用npm安装npm install -g yarn 查看版本：yarn --version// 2、安装node.js,下载yarn的安装程序// 下载地址 https://yarn.bootcss.com/docs/install/#windows-stable 创建项目安装Node&gt; = 6和npm&gt; = 5.212345678910111213141516171819202122232425262728293031323334353637// 已安装Node&gt; = 6和npm&gt; = 5.2// 老方法npm install -g create-react-appcreate-react-app my-app// npx方式npx create-react-app my-app// npx介绍-可忽略// npm v5.2.0引入的一条命令（npx），引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。// 这条命令会临时安装 create-react-app 包，命令完成后create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。// npx 会帮你执行依赖包里的二进制文件。// 举例来说，之前我们可能会写这样的命令：npm i -D webpack./node_modules/.bin/webpack -v// 如果你对 bash 比较熟，可能会写成这样：npm i -D webpack`npm bin`/webpack -v// 有了 npx，你只需要这样：npm i -D webpacknpx webpack -v// 也就是说 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！// npx 甚至支持运行远程仓库的可执行文件：npx github:piuccio/cowsay hello// 再比如 npx http-server 可以一句话帮你开启一个静态服务器！（第一次运行会稍微慢一些）npx http-server// 指定node版本来运行npm scripts：npx -p node@8 npm run build// 主要特点：// 1、临时安装可执行依赖包，不用全局安装，不用担心长期的污染。// 2、可以执行依赖包中的命令，安装完成自动运行。// 3、自动加载node_modules中依赖包，不用指定$PATH。// 4、可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux服务器配置]]></title>
    <url>%2Ffrontend%2F2019%2F01%2F23%2Flinux%2F</url>
    <content type="text"><![CDATA[linux服务器配置 新购服务器配置12345678910111213//下载nodewget https://nodejs.org/download/release/v8.11.1/node-v8.11.1-linux-x64.tar.gz//解压nodetar -xzvf node-v8.11.1-linux-x64.tar.gz//移动mv node-v8.11.1-linux-x64 /usr/local/node//cd到/usr/local/node/bin 做软链-为了全局访问//若提示Permission denied，前面加sudoln -s /usr/local/node/bin/node /usr/local/bin/ln -s /usr/local/node/bin/npm /usr/local/bin///yarn安装//参考官网 https://yarnpkg.com/zh-Hans/docs/install#debian-stable 12345678910111213141516//git安装sudo apt install git//检测是否安装成功git --version//git配置git config --global user.name '名字'git config --global user.email '邮箱'//生成ssh秘钥ssh-keygen -t rsa -C '邮箱'//查看秘钥~/.ssh/id_rsa.pub//安装Nginx//参考地址https://cloud.tencent.com/developer/article/1353638sudo apt-get updatesudo apt-get install nginx 生产环境配置123456789101112131415161718192021222324252627282930313233343536ubuntu@VM-0-7-ubuntu:/$ sudo mkdir developubuntu@VM-0-7-ubuntu:/$ sudo mkdir productubuntu@VM-0-7-ubuntu:/$ sudo mv develop developerubuntu@VM-0-7-ubuntu:/$ cd developer/ubuntu@VM-0-7-ubuntu:/developer$ sudo mkdir git-repositoryubuntu@VM-0-7-ubuntu:/developer$ lsgit-repositoryubuntu@VM-0-7-ubuntu:/developer$ cd git-repository/ubuntu@VM-0-7-ubuntu:/developer/git-repository$ git clone git@github.com:zlyyyy/zzMusic.gitubuntu@VM-0-7-ubuntu:/developer/git-repository$ sudo git clone git@github.com:zlyyyy/zzMusic.gitCloning into 'zzMusic'...The authenticity of host 'github.com (13.229.188.59)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com,13.229.188.59' (RSA) to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.ubuntu@VM-0-7-ubuntu:/developer/git-repository$ ssh-keygen -t rsa -C "zlyyyy"Generating public/private rsa key pair.Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa): /home/ubuntu/.ssh/id_rsa already exists.Overwrite (y/n)? u^H^H^H^H^[[D^[[B^H^H^[[2~^H^H^[[D^[[D ^H^Hubuntu@VM-0-7-ubuntu:/developer/git-repository$ ssh-keygen -t rsa -C "zlyyyy"Generating public/private rsa key pair.//参考链接 https://blog.csdn.net/u014343528/article/details/48787221cat: /User/username/.ssh/id_rsa.pub: No such file or directoryubuntu@VM-0-7-ubuntu:/developer/git-repository$ cat /home/ubuntu/.ssh/id_rsa.pububuntu@VM-0-7-ubuntu:/developer/git-repository$ sudo git clone git@github.com:zlyyyy/zzMusic.gitCloning into 'zzMusic'...Warning: Permanently added the RSA host key for IP address '52.74.223.119' to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository. 12345678910111213141516s.test.com.conf server &#123; listen 80; server_name s.test.cn; access_log /etc/nginx/logs/access.log combined; index index.html index.jsp index.php; location ~ /zzMusic/dist/view/* &#123; deny all; &#125; location / &#123; root /product/front/; add_header Access-Control-Allow-Origin '*'; &#125;&#125; 12345678910111213141516171819202122music.test.com.confserver &#123; listen 80; server_name music.zhaoly.cn; access_log /etc/nginx/logs/access.log combined; index index.html index.jsp index.php; location = / &#123; root /product/front/zzMusic/dist; index index.html; &#125; location ~ .*\.html$ &#123; root /product/front/zzMusic/dist; index index.html; &#125; location ~ .*\.do$ &#123; proxy_pass http://music.zhaoly.cn; &#125; location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 报错nginx: [emerg] host not found in upstream “music.test.cn” in /usr/local/nginx/conf/vhost/yq.nginx.com.conf:19 这个错误。解决vim /etc/hosts 修改hosts文件，在hosts文件里面加上一句 127.0.0.1 localhost.localdomain music.test.cn]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>服务器配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.x开发环境配置]]></title>
    <url>%2Ffrontend%2F2018%2F09%2F12%2Fwebpack%2F</url>
    <content type="text"><![CDATA[webpack4.x学习，是总结也是笔记，网上的各种答案杂又乱，基于自己学习以及综合其他各种答案自己梳理总结了一篇完整的webpack4.x配置使用。这里我安装的webpack版本为4.17.2，webpack-cli版本为3.1.0 一、全局安装webpack1npm install webpack webpack-cli -g 二、创建项目随便哪个盘先建个webpack-test的项目文件夹，命令行进入项目文件夹，开始项目初始化1npm init 一路回车，最终在项目根目录下生成package.json文件 三、项目本地安装webpack 将所安装的包分类到开发模式下，并写入到 package.json 配置文件1npm install webpack webpack-cli --save-dev 打开package.json，看到以下三行，代表安装成功1234"devDependencies": &#123; "webpack": "^4.17.2", "webpack-cli": "^3.1.0" &#125; 四、创建项目文件创建项目架构与文件尝试打包1webpack test.js test.bundle.js 运行报错1234567891011WARNING in configurationThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/ERROR in multi test.js test.bundle.jsModule not found: Error: Can't resolve 'test.bundle.js' in 'F:\webpack-test' @ multi test.js test.bundle.js main[1]ERROR in multi test.js test.bundle.jsModule not found: Error: Can't resolve 'test.js' in 'F:\webpack-test' @ multi test.js test.bundle.js main[0] 配置警告“mode”选项尚未设置，WebPACK将回落到“production”这个值。将“mode”选项设置为“development”或“production”，以启用每个环境的默认值。您也可以将其设置为“NONE”以禁用任何默认行为。了解更多：HTTPS://WebPACK.JS.Org/Vistus/MODE/ 第一个问题没有配置webpack的mode选项，默认有production和development两种模式可以设置，我们设置为development模式测试，命令行输入1webpack --mode development 依旧报错1ERROR in Entry module not found: Error: Can't resolve './src' in 'F:\webpack-test' 未找到输入模块中的错误：无法在’F:\webpack-test’解析’./src’ 五、创建入口文件 解决上述报错问题，将test.js移动到src目录下，并重命名为index.js 解析：webpack4.x是以项目根目录下的‘./src’作为入口，但我们的项目中缺乏该路径，因此我们在根目录下创建src文件夹，事实上webpack4.x以‘./src/index.js’作为入口，单单创建src文件而没有index.js文件仍然会报错,所以我们会有上述操作现在我们再次打包1webpack index.js index.bundle.js 依旧报错。 解析：webpack4.x的打包已经不能用webpack 文件a 文件b的方式，而是直接运行webpack –mode development或者webpack –mode production，这样便会默认进行打包，入口文件是‘./src/index.js’，输出路径是‘./dist/main.js’，其中src目录即index.js文件需要手动创建，而dist目录及main.js会自动生成。 所以我们运行1webpack --mode development 或者1webpack --mode production 这时dist目录下已经有了main.js，表示我们已经打包成功为了简化操作，在package.json中scripts中添加：12"dev":"webpack --mode development","build":"webpack --mode production" 之后打包只需要在命令行执行npm run dev(等于webpack –mode development)，执行npm run build(等于webpack –mode production)删除之前dist文件夹下的main.js，命令行执行1npm run dev dist目录下已经生成了main.js，main.js文件已经打包了src目录下index.js文件的代码 dev与build区别我们再次执行npm run build1npm run build 结果如下图所示执行 npm run dev 打包的是未压缩的代码，而 npm run build 是压缩后的代码。 webpack –mode production 生产模式下：启用了 代码压缩、作用域提升（scope hoisting）、 tree-shaking，使代码最精简。 webpack –mode development 开发模式下：相较于更小体积的代码，提供的是打包速度上的优化。 六、配置其他的参数webpack官网的命令行接口，顾名思义就是webpack指令的其他参数，只需要在webpack –mode production/development后加上其他参数即可，如：1webpack --mode development --watch --progress --display-modules --colors --display-reasons 我们把这段写入package.json的scripts之中，这样就不用每次打这么长一串了。 –watch(观察文件系统的变化)，–progress(显示打包过程中的进度)，–display-modules(在输出中显示所有模块，包括被排除的模块)，–color, –colors(开启/关闭控制台的颜色)，–display-reasons(显示模块包含在输出中的原因)，更多配置可以参阅webpack官网 七、总结注意事项： 1、webpack-cli必须要全局安装，否则不能使用webpack指令。 2、webpack也必须要全局安装，否则也不能使用webpack指令。 3、webpack4.x中webpack.config.js这样的配置文件不是必须的。 4、默认入口(entry)文件是./src/index.js，默认输出(output)文件./dist/main.js。 配置步骤： 1、创建工程目录；2、初始化工程目录：npm init。3、全局安装webpack-cli。4、全局安装webpack。5、webpack –mode development/production进行打包，可在package.json中配置dev和build的脚本，便只需运行npm run dev/build，作用相同。6、在webpack –mode development/production可串联设置其他参数。 这只是webpack的基本环境配置，后续会基于实际项目使用深入学习。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端自动化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中sass配置]]></title>
    <url>%2Ffrontend%2F2018%2F09%2F07%2Fvue-sass%2F</url>
    <content type="text"><![CDATA[vue中sass配置 做了个vue项目练手，官方的脚手架中没有sass的模板的编译，想在其中使用sass怎么办？ 1、首先下载sass的依赖包12345npm install sass-loader --save-dev//sass-loader依赖于node-sassnpm install node-sass --save-dev //安装style-loader 与vue-style-loader 是一样的npm install style-loader --save-dev 快捷方式1npm install sass-loader node-sass vue-style-loader --D 2、在build文件夹下的webpack.base.conf.js的rules里面添加配置12345678910111213141516171819202122232425262728293031323334353637383940414243module: &#123; rules: [ &#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125;, //添加下面这一段代码 &#123; test: /\.sass$/, loaders: ['style', 'css', 'sass'] &#125;, ] &#125; 3、在需要用到sass的地方修改style标签12345678910&lt;style lang="scss" scoped="" type="text/css"&gt;//你的sass语言$font-color: #333;body &#123; color: $font-colo; //编译后为color:#333，类似于js的变量&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>sass</tag>
        <tag>css预编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp安装和简单使用]]></title>
    <url>%2Ffrontend%2F2018%2F09%2F04%2Fgulp%2F</url>
    <content type="text"><![CDATA[一、安装nodejs nodejs官网下载安装文件安装 安装完成后，终端输入node-v打印出nodejs的版本号，这时候nodejs已经安装成功 新版本的nodejs集成了npm。终端输入npm-v打印出npm的版本号 二、安装gulp(全局) 终端输入 1npm install gulp -g 测试安装是否成功，终端输入gulp-v 三、配置项目 package.json是基于node.js项目必不可少的配置文件，用于存放项目根目录的普通json文件重点内容 在终端进入文件根目录，执行npm init，一路回车，最终在项目根目录下生成package.json文件 1234567891011&#123; "name": "gulp_test", /*项目名,切记这里命名不要与模块一样，如命名为gulp，要地安装gulp时就会出错*/ "version": "1.0.0", /*版本号*/ "description": "", /*描述*/ "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", /*作者*/ "license": "ISC" /*项目许可协议*/&#125; 四、本地安装gulp及gulp插件本地安装gulp 全局安装gulp是为了执行gulp任务，本地安装gulp是为了调用gulp插件的功能进入你的项目文件路径中 1npm install gulp --save-dev –svae-dev 的作用就是将安装的模块写入package.json中 安装完成后项目变化 node_modules文件夹&gt;&gt;gulp模块被下载到这个文件夹中 package.json中写入了devDependencies字段，并在该字段下填充了gulp模块名 本地安装gulp插件 这里我们安装使用最多的必备的几个插件 删除文件–del 语法检查–gulp-jshint 合并文件–gulp-concat 压缩代码–gulp-uglify 文件重命名–gulp-rename css压缩–gulp-minify-css 1npm install --save-dev del jshint gulp-jshint gulp-concat gulp-uglify gulp-rename gulp-minify-css npm安装插件，可以单独安装，也可以几个一起安装空格隔开。 单独安装1npm install --save-dev del 上面jshint gulp-jshint说明gulp-jshint 2.0版本必须先下载jshint，使用npm安装：1npm install jshint gulp-jshint 五、创建gulpfile.js文件 gulp只有五个方法src，task，dest，run，watch 在项目根目录下创建gulpfile.js文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*引入gulp及相关插件 require('node_modules里对应模块')*/var gulp = require('gulp');var jshint = require('gulp-jshint');//js检查var concat = require('gulp-concat');//js合并var uglify = require('gulp-uglify');//js压缩var rename = require('gulp-rename');//文件重命名var minifycss = require('gulp-minify-css');//css压缩var del = require('del');//文件删除//创建任务，进行js代码检查gulp.task('jshint',function()&#123; return gulp.src('js/**/*.js') //检查文件：js目录下所有的js文件 .pipe(jshint()) //进行js检查 .pipe(jshint.reporter('default')); //对代码进行报错提示&#125;);//创建任务，进行js压缩gulp.task('script', function () &#123; return gulp.src('js/**/*.js') //检查文件：js目录下所有的js文件 .pipe(concat('all.js')) //合并all.js文件 .pipe(gulp.dest('dist')) //合并后的文件输出的目录 .pipe(uglify()) //压缩all.js文件 .pipe(rename(&#123;suffix: '.min'&#125;))//rename压缩后的文件名 .pipe(gulp.dest('dist/js/')); //压缩后的文件输出的目录&#125;);//创建任务，进行css压缩gulp.task('minifycss', function () &#123; return gulp.src('css/**/*.css') //获取文件：css目录下所有的css文件 .pipe(minifycss()) //执行压缩 .pipe(rename(&#123;suffix: '.min'&#125;))//rename压缩后的文件名 .pipe(gulp.dest('dist/css/')); //压缩后的文件输出的目录&#125;);//实时监听文件变化，执行各个任务gulp.task('watch', function () &#123; gulp.watch('js/**/*.js', ['jshint']); gulp.watch('js/**/*.js', ['script']); gulp.watch('css/**/*.css', ['minifycss']);&#125;);//在编译文件之前删除一些文件gulp.task('clean', function () &#123; return del('dist/**/*');&#125;);//默认任务gulp.task('default', ['clean'], function () &#123; gulp.run('jshint','script', 'minifycss', 'watch');&#125;); 六、运行gulp在终端输入并回车执行1gulp]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>gulp</tag>
        <tag>前端自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基本算法]]></title>
    <url>%2Ffrontend%2F2018%2F08%2F27%2Fjs-algorithm%2F</url>
    <content type="text"><![CDATA[时间复杂度：算法的时间复杂度是一个函数，描述了算法的运行时间。时间复杂度越低，效率越高 一个算法，运行了几次时间复杂度就为多少，如运行了n次，则时间复杂度为O(n) 1、冒泡排序 比较相邻的两个元素，如果前一个比后一个大，则交换位置。按照相邻元素的比较，第一轮的时候最后一个元素已经为最大的一个，所以最后一个元素不用比较 12345678910111213141516 function bubbleSort(arr)&#123; for(var i=0; i&lt;arr.length-1; i++)&#123; for(var j=0; j&lt;arr.length-i-1; j++)&#123; //&gt;从小到大排序 //&lt;从大到小排序 if(arr[j] &gt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp &#125; &#125; &#125; return arr;&#125;var arr=[5,6,2,1,3,8,7,1.2,5.5,4.5];console.log(bubbleSort(arr)); 2、快速排序 快速排序是对冒泡排序的一种改进，第一次排序时将数据分为两部分，一部分比另一部分的所有数据都要小。然后递归调用，在两边都实行快速排序。 123456789101112131415161718192021function quickSort(arr)&#123; if(arr.length &lt;= 1)&#123;return arr;&#125; //中心点 var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = [], right = []; //左右都实行快速排序 for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i] &lt; pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; //递归 连接左右 return quickSort(left).concat([pivot], quickSort(right));&#125;var arr=[5,6,2,1,3,8,7,1.2,5.5,4.5];console.log(quickSort(arr)); 3、判断一个单词是否有回文 回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider 123function checkPalindrom(str) &#123; return str == str.split('').reverse().join('');&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http和https的区别与联系]]></title>
    <url>%2Ffrontend%2F2018%2F08%2F21%2Fhttp-diffr%2F</url>
    <content type="text"><![CDATA[超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 一、HTTP和HTTPS的基本概念HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。二、HTTP与HTTPS有什么区别？ HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。 简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 HTTPS和HTTP的区别主要如下： https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 三、HTTPS的工作原理 我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 客户端发起HTTPS请求 这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。 这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。 如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。 六、HTTPS的优点 正是由于HTTPS非常的安全，攻击者无法从中找到下手的地方，从站长的角度来说，HTTPS的优点有以下2点： SEO方面 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 安全性 尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处： （1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 （3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 七、HTTPS的缺点 虽然说HTTPS有很大的优势，但其相对来说，还是有些不足之处的，具体来说，有以下2点： SEO方面 据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。 而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。 最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 经济方面 （1）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 （2）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。 （3）HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。 （4）HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。 （5）HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现继承的方式]]></title>
    <url>%2Ffrontend%2F2018%2F08%2F21%2Fjs-inherit%2F</url>
    <content type="text"><![CDATA[js实现继承的方式 JS作为面向对象的弱类型语言，继承是其非常强大的特性之一 定义一个父类12345678910111213//定义一个动物类function Animal(name)&#123; //属性 this.name = name || 'Animal'; //实例方法 this.sleep = function()&#123; console.log(this.name + '正在睡觉'); &#125;&#125;//原型方法Animal.prototype.eat = function(food)&#123; console.log(this.name + '正在吃' + food)&#125; 1、原型链继承 核心：将父类的实例作为子类的原型 123456789101112function Cat()&#123;&#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat'//testvar cat = new Cat();console.log(cat.name);//catconsole.log(cat.eat('fish'));//cat正在吃fishconsole.log(cat.sleep());//cat正在睡觉console.log(cat instanceof Animal);//trueconsole.log(cat instanceof Cat);//true 特点 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点 要想为子类新增属性和方法，可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 2、构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 1234567891011function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom'&#125;//testvar cat = new Cat();console.log(cat.name);//Tomconsole.log(cat.sleep());//Tom正在睡觉console.log(cat instanceof Animal);//falseconsole.log(cat instanceof Cat);//true 特点 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象） 缺点 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 3、实例继承 核心：为父类实例添加新特性，作为子类实例返回 123456789101112function Cat(name)&#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;//testvar cat = new Cat();console.log(cat.name);//Tomconsole.log(cat.sleep());//Tom正在睡觉console.log(cat instanceof Animal);//trueconsole.log(cat instanceof Cat);//false 特点 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果 缺点 实例是父类的实例，不是子类的实例 不支持多继承 4、拷贝继承1234567891011121314function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125;//testvar cat = new Cat();console.log(cat.name);//Tomconsole.log(cat.sleep());//Tom正在睡觉console.log(cat instanceof Animal);//falseconsole.log(cat instanceof Cat);//true 特点 支持多继承 缺点 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 5、组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 1234567891011121314function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();//组合继承需要修复构造函数指向的。Cat.prototype.constructor = Cat;//testvar cat = new Cat();console.log(cat.name);//Tomconsole.log(cat.sleep());//Tom正在睡觉console.log(cat instanceof Animal);//trueconsole.log(cat instanceof Cat);//true 特点 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 6、寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 12345678910111213141516171819function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();Cat.prototype.constructor = Cat; // 需要修复下构造函数//testvar cat = new Cat();console.log(cat.name);//Tomconsole.log(cat.sleep());//Tom正在睡觉console.log(cat instanceof Animal);//trueconsole.log(cat instanceof Cat);//true 特点 堪称完美 缺点 实现较为复杂]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>继承方式</tag>
      </tags>
  </entry>
</search>
